tumple,pair,alloca，priority_queue,auto和decltype，c++ 后置返回类型，functional，thread,chrono，继承时构造函数和类中有别的类构造函数，c++五法则


c++不使用初始化列表会调用两次构造函数。
左值引用只接受左值
右值引用只接受右值
左值是有储存支持的变量，右值是临时变量。
const int& 常量左值引用可以接受左值和右值。
移动构造函数在创建对象时调用，移动赋值在移动对象使用。


const:
const对象只能调用const成员函数、不能调用非const成员函数。（因为类型不匹配）
非const对象可以调用const成员函数。（const成员已经限定了无法修改，可以访问）



类的学习：

类的静态成员变量类内声明类外初始化。静态成员函数只能访问静态成员变量。类A内声明：static int a;	类外初始化：int A::a=10;	静态变量可以由类名和类的对象来访问。非static成员函数可访问static态成员函数/成员。
非static成员函数隐含有this指针，谁调函数，this指向该对象。而静态函数没有该指针因此无法调用非静态成员，因为无法确定哪一个对象的。
static成员函数通过访问类对象间接访问非static成员函数/成员。



类的普通函数是共享一块代码区，在调用成员函数时，编译器会根据类的类型找类函数。所以假设B继承A，A *ptr=new B; A->func();只能调用A类中的函数。


多态原理，继承时虚函数表指针是深拷贝。重写虚函数，是重写子类的虚函数表地址并指向重写的函数。假设B继承A，A *ptr=new B; A->virtual func();时要找虚函数表指针，而指向的实例为B，即拿到的是B的虚函数表指针，所以调用的是B重写的虚函数。

